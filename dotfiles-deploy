#!/bin/bash
# Smart deployment script for new machines with GNU Stow

set -e
# Debug: uncomment to see what command fails
# set -x

# Default configuration
DOTFILES="${DOTFILES:-$HOME/dotfiles}"
TARGET_DIR="$HOME"
BACKUP_DIR="$HOME/config-backup-$(date +%Y%m%d_%H%M%S)"
DRY_RUN=false
NO_PROMPT=false
AUTO_YES=false
SELECTIVE_MODE=false
SELECTED_PACKAGES=()
FAILED_PACKAGES=()
ROLLBACK_NEEDED=false
OPERATIONS=()

# Use tput for portable colors if available (consistent with dotfiles-add)
if command -v tput >/dev/null 2>&1; then
    RED=$(tput setaf 1)
    GREEN=$(tput setaf 2)
    YELLOW=$(tput setaf 3)
    BLUE=$(tput setaf 4)
    BOLD=$(tput bold)
    RESET=$(tput sgr0)
else
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    BOLD='\033[1m'
    RESET='\033[0m'
fi

print_success() {
    echo -e "${GREEN}‚úì${RESET} $1"
}

print_warning() {
    echo -e "${YELLOW}‚ö†${RESET} $1"
}

print_error() {
    echo -e "${RED}‚úó${RESET} $1"
}

print_dry_run() {
    echo -e "${BOLD}[DRY RUN]${RESET} $1"
}

print_header() {
    echo -e "${BLUE}========================================${RESET}"
    echo -e "${BLUE}  Dotfiles Deployment${RESET}"
    echo -e "${BLUE}========================================${RESET}"
}

# Help text
print_help() {
    cat << EOF
${BOLD}Dotfiles Deployment${RESET}
Deploy dotfiles packages with GNU Stow.

${BOLD}Usage:${RESET}
  $(basename "$0") [OPTIONS] [PACKAGE...]

${BOLD}Options:${RESET}
  -h, --help           Show this help message
  -d, --dry-run        Preview changes without making them
  -y, --yes            Assume 'yes' to all prompts
  -n, --no-prompt      Non-interactive mode (fails if input needed)
  -t, --target DIR     Stow target directory (default: ~)
  --no-backup          Skip backing up existing files
  --adopt              Use stow --adopt to keep existing files
  --skip PACKAGE       Skip specific package(s)
  --only PACKAGE       Deploy only specific package(s)

${BOLD}Examples:${RESET}
  $(basename "$0")                    # Deploy all packages
  $(basename "$0") -d                 # Preview deployment
  $(basename "$0") -y                 # Auto-accept all conflicts
  $(basename "$0") polybar i3         # Deploy only polybar and i3
  $(basename "$0") -t /custom/target  # Deploy to custom location
  $(basename "$0") --adopt            # Keep existing files with --adopt

${BOLD}Environment:${RESET}
  DOTFILES    Directory containing dotfiles (default: ~/dotfiles)
EOF
    exit 0
}

# Parse command line arguments
parse_args() {
    local skip_packages=()
    local only_packages=()

    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                print_help
                ;;
            -d|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -y|--yes)
                AUTO_YES=true
                shift
                ;;
            -n|--no-prompt)
                NO_PROMPT=true
                shift
                ;;
            -t|--target)
                TARGET_DIR="$2"
                shift 2
                ;;
            --no-backup)
                NO_BACKUP=true
                shift
                ;;
            --adopt)
                USE_ADOPT=true
                shift
                ;;
            --skip)
                skip_packages+=("$2")
                shift 2
                ;;
            --only)
                only_packages+=("$2")
                SELECTIVE_MODE=true
                shift 2
                ;;
            --)
                shift
                break
                ;;
            -*)
                echo "Error: Unknown option $1" >&2
                echo "Use --help for usage information" >&2
                exit 1
                ;;
            *)
                SELECTED_PACKAGES+=("$1")
                SELECTIVE_MODE=true
                shift
                ;;
        esac
    done

    # Handle --skip and --only options
    if [ ${#skip_packages[@]} -gt 0 ]; then
        SKIP_PACKAGES=("${skip_packages[@]}")
    fi
    if [ ${#only_packages[@]} -gt 0 ]; then
        SELECTED_PACKAGES=("${only_packages[@]}")
        SELECTIVE_MODE=true
    fi
}

# Check if package should be deployed
should_deploy_package() {
    local package="$1"

    # Skip .git or non-directories
    if [[ "$package" == ".git" ]] || [[ ! -d "$package" ]]; then
        return 1
    fi

    # Skip packages in skip list
    if [[ " ${SKIP_PACKAGES[@]} " =~ " ${package} " ]]; then
        print_warning "Skipping package: $package (--skip)"
        return 1
    fi

    # If selective mode, only deploy selected packages
    if [ "$SELECTIVE_MODE" = true ] && [[ ! " ${SELECTED_PACKAGES[@]} " =~ " ${package} " ]]; then
        return 1
    fi

    return 0
}

# Atomic backup operation
atomic_backup() {
    local source_path="$1"
    local backup_path="$2"

    if [ "$NO_BACKUP" = true ]; then
        print_warning "Skipping backup (--no-backup): $source_path"
        return 0
    fi

    if [ "$DRY_RUN" = true ]; then
        print_dry_run "Would backup: $source_path ‚Üí $backup_path"
        return 0
    fi

    # Create backup directory
    mkdir -p "$(dirname "$backup_path")" || {
        print_error "Failed to create backup directory: $(dirname "$backup_path")"
        return 1
    }

    # Use atomic operations
    if [ -d "$source_path" ]; then
        cp -r "$source_path" "$backup_path.tmp" && mv "$backup_path.tmp" "$backup_path"
    else
        cp "$source_path" "$backup_path.tmp" && mv "$backup_path.tmp" "$backup_path"
    fi

    if [ $? -eq 0 ]; then
        OPERATIONS+=("backup:$source_path:$backup_path")
        print_success "Backed up: $source_path ‚Üí $backup_path"
    else
        print_error "Failed to backup: $source_path"
        return 1
    fi
}

# Atomic rename/move operation
atomic_rename() {
    local source_path="$1"
    local dest_path="$2"

    if [ "$DRY_RUN" = true ]; then
        print_dry_run "Would rename: $source_path ‚Üí $dest_path"
        return 0
    fi

    # Use mv with backup if destination exists
    if [ -e "$dest_path" ]; then
        local counter=1
        while [ -e "${dest_path}.old${counter}" ]; do
            ((counter++))
        done
        dest_path="${dest_path}.old${counter}"
    fi

    mv "$source_path" "$dest_path" && {
        OPERATIONS+=("rename:$source_path:$dest_path")
        print_success "Renamed: $source_path ‚Üí $dest_path"
    }
}

# Handle conflicts for a package
handle_conflicts() {
    local package="$1"
    local conflicts=()

    # Use process substitution to avoid pipe with set -e
    # Use a temporary file to avoid issues with process substitution
    local temp_file
    temp_file=$(mktemp) || {
        print_error "Failed to create temporary file"
        return 1
    }

    # Find files and write to temp file
    find "$package" -type f 2>/dev/null > "$temp_file" || true

    while IFS= read -r file; do
        local target_file="${file#$package/}"
        local target_path="$TARGET_DIR/$target_file"

        # Check if file exists and is not a symlink
        if [ -e "$target_path" ] && [ ! -L "$target_path" ]; then
            conflicts+=("$target_file:$target_path")
        fi
    done < "$temp_file"

    rm -f "$temp_file"

    if [ ${#conflicts[@]} -eq 0 ]; then
        return 0
    fi

    echo ""
    print_warning "Found ${#conflicts[@]} conflict(s) for package: $package"

    local resolved_conflicts=0
    local skipped_conflicts=0

    for conflict in "${conflicts[@]}"; do
        local target_file="${conflict%%:*}"
        local target_path="${conflict#*:}"
        local backup_path="$BACKUP_DIR/$target_file"

        if [ "$AUTO_YES" = true ]; then
            # Auto-resolve: backup and rename
            atomic_backup "$target_path" "$backup_path"
            atomic_rename "$target_path" "${target_path}.old"
            ((resolved_conflicts++))
        elif [ "$NO_PROMPT" = true ]; then
            # Non-interactive: skip or fail
            print_error "Conflict in non-interactive mode: $target_file"
            ((skipped_conflicts++))
        else
            # Interactive mode
            echo ""
            echo "Conflict: $target_file"
            echo "  Existing: $target_path"
            echo "  Would be: $DOTFILES/$package/$target_file"
            echo ""
            echo "Options:"
            echo "  1) Backup and rename to .old (default)"
            echo "  2) Skip this file"
            echo "  3) Skip entire package"
            echo "  4) Abort deployment"
            echo ""
            read -p "Choose option [1/2/3/4]: " -n 1 -r
            echo ""

            case $REPLY in
                1|"")
                    atomic_backup "$target_path" "$backup_path"
                    atomic_rename "$target_path" "${target_path}.old"
                    ((resolved_conflicts++))
                    ;;
                2)
                    print_warning "Skipping file: $target_file"
                    ((skipped_conflicts++))
                    ;;
                3)
                    print_warning "Skipping entire package: $package"
                    return 2  # Skip package
                    ;;
                4)
                    print_error "Deployment aborted by user"
                    exit 1
                    ;;
                *)
                    print_warning "Invalid option, skipping file: $target_file"
                    ((skipped_conflicts++))
                    ;;
            esac
        fi
    done

    if [ $skipped_conflicts -gt 0 ]; then
        print_warning "Skipped $skipped_conflicts conflict(s) for package: $package"
    fi

    return 0
}

# Deploy a single package
deploy_package() {
    local package="$1"
    local stow_opts="-t \"$TARGET_DIR\""

    if [ "$USE_ADOPT" = true ]; then
        stow_opts="$stow_opts --adopt"
    fi

    if [ "$DRY_RUN" = true ]; then
        print_dry_run "Would deploy: $package to $TARGET_DIR"
        return 0
    fi

    print_success "Deploying: $package"

    # Track for rollback
    ROLLBACK_NEEDED=true
    local pre_ops_count=${#OPERATIONS[@]}

    # Handle conflicts
    handle_conflicts "$package"
    local conflict_status=$?
    if [ $conflict_status -eq 2 ]; then
        # Package skipped due to conflicts
        return 1
    fi

    # Deploy with stow
    cd "$DOTFILES"
    local stow_cmd="stow -v $stow_opts \"$package\""
    if eval "$stow_cmd"; then
        OPERATIONS+=("stow:$package:$TARGET_DIR:${#OPERATIONS[@]}:$pre_ops_count")
        print_success "Successfully deployed: $package"
        return 0
    else
        print_error "Failed to deploy: $package"
        FAILED_PACKAGES+=("$package")
        return 1
    fi
}

# Rollback operations for a package
rollback_package() {
    local package="$1"
    local start_index="$2"
    local end_index="$3"

    print_warning "Rolling back package: $package"

    # Process operations in reverse order
    for (( i=end_index; i>=start_index; i-- )); do
        local op="${OPERATIONS[i]}"
        local type="${op%%:*}"
        local details="${op#*:}"

        case "$type" in
            "backup")
                local source_path="${details%%:*}"
                local backup_path="${details#*:}"
                # Backup exists, nothing to rollback
                ;;
            "rename")
                local source_path="${details%%:*}"
                local dest_path="${details#*:}"
                if [ -e "$dest_path" ]; then
                    mv "$dest_path" "$source_path" 2>/dev/null && print_success "Restored: $source_path"
                fi
                ;;
            "stow")
                local stow_details="${details#*:}"
                local target="${stow_details%%:*}"
                local rest="${stow_details#*:}"
                local pkg="${rest%%:*}"
                cd "$DOTFILES"
                stow -D -t "$target" "$pkg" 2>/dev/null && print_success "Unstowed: $pkg from $target"
                ;;
        esac
    done
}

# Main deployment function
main() {
    parse_args "$@"

    print_header

    # Check dependencies
    if ! command -v stow >/dev/null 2>&1; then
        print_error "GNU Stow is not installed"
        echo "Install it with:"
        echo "  Ubuntu/Debian: sudo apt install stow"
        echo "  Arch: sudo pacman -S stow"
        echo "  macOS: brew install stow"
        exit 1
    fi

    # Check dotfiles directory
    if [ ! -d "$DOTFILES" ]; then
        print_error "Dotfiles directory not found: $DOTFILES"
        exit 1
    fi

    # Create backup directory if needed
    if [ "$NO_BACKUP" != true ] && [ "$DRY_RUN" != true ]; then
        mkdir -p "$BACKUP_DIR" || {
            print_error "Failed to create backup directory: $BACKUP_DIR"
            exit 1
        }
    fi

    if [ "$DRY_RUN" = true ]; then
        print_dry_run "Preview mode - no changes will be made"
    fi

    cd "$DOTFILES"

    local packages=()
    for package in */; do
        package=${package%/}
        if should_deploy_package "$package"; then
            packages+=("$package")
        fi
    done

    if [ ${#packages[@]} -eq 0 ]; then
        print_warning "No packages to deploy"
        exit 0
    fi

    echo ""
    print_success "Packages to deploy: ${packages[*]}"
    echo ""

    # Ask for confirmation
    if [ "$DRY_RUN" != true ] && [ "$AUTO_YES" != true ] && [ "$NO_PROMPT" != true ]; then
        echo "Target directory: $TARGET_DIR"
        echo "Backup directory: $BACKUP_DIR"
        echo "Packages: ${#packages[@]}"
        echo ""
        read -p "Continue with deployment? (y/N): " -n 1 -r
        echo ""
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            print_warning "Deployment cancelled"
            exit 0
        fi
    fi

    # Deploy packages
    local deployed_count=0
    local failed_count=0

    for package in "${packages[@]}"; do
        echo ""
        echo "üì¶ Package: $package"

        local start_ops=${#OPERATIONS[@]}

        if deploy_package "$package"; then
            deployed_count=$((deployed_count + 1))
        else
            failed_count=$((failed_count + 1))
            # Rollback this package if it failed after starting operations
            if [ $start_ops -lt ${#OPERATIONS[@]} ]; then
                rollback_package "$package" "$start_ops" "$((${#OPERATIONS[@]} - 1))"
                # Remove rolled back operations
                OPERATIONS=("${OPERATIONS[@]:0:$start_ops}")
            fi
        fi
    done

    echo ""
    echo "========================================"
    if [ "$DRY_RUN" = true ]; then
        print_dry_run "Deployment preview complete"
        print_dry_run "Would deploy: $deployed_count package(s)"
        if [ $failed_count -gt 0 ]; then
            print_dry_run "Would fail: $failed_count package(s)"
        fi
    else
        if [ $failed_count -eq 0 ]; then
            print_success "Deployment complete!"
            print_success "Successfully deployed: $deployed_count package(s)"

            if [ "$NO_BACKUP" != true ] && [ -d "$BACKUP_DIR" ] && [ "$(ls -A "$BACKUP_DIR" 2>/dev/null)" ]; then
                echo ""
                echo "üìÅ Backups saved to: $BACKUP_DIR"
                echo ""
                echo "To restore any backup:"
                echo "  cp -r $BACKUP_DIR/path/to/file $TARGET_DIR/original/location/"
            fi
        else
            print_error "Deployment completed with errors"
            print_success "Successfully deployed: $deployed_count package(s)"
            print_error "Failed: $failed_count package(s)"
            echo "Failed packages: ${FAILED_PACKAGES[*]}"
            exit 1
        fi
    fi
}

# Run main function
main "$@"
