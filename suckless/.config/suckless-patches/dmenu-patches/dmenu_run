#!/bin/bash

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Get commands from dmenu_path
commands=$("$SCRIPT_DIR/dmenu_path" | sed 's/^/CMD: /')

# Get desktop applications from dmenu_desktop
applications=$("$SCRIPT_DIR/dmenu_desktop" | sed 's/^/APP: /')

# Combine and interleave items so apps appear mixed with commands
# This prevents all 2968 commands from appearing before the 88 apps
# Use a simpler approach: put apps first since there are fewer of them
combined_list=$( { echo "$applications"; echo "$commands"; } )

# Use case-insensitive matching by default since desktop app names are often capitalized
# while command names are lowercase. Users can override with -s if they want case-sensitive.
# Use dmenu from the same directory
selected_item=$(printf "%s\n" "$combined_list" | "$SCRIPT_DIR/dmenu" -i "$@")
selected_item=$(echo "$selected_item" | tr -d '\n' | sed 's/^[ \t]*//;s/[ \t]*$//') # Trim whitespace and newlines

if [ -n "$selected_item" ]; then
    if [[ "$selected_item" == "CMD: "* ]]; then
        command=$(echo "$selected_item" | sed 's/^CMD: //')
        exec ${SHELL:-"/bin/sh"} -c "$command" &
    elif [[ "$selected_item" == "APP: "* ]]; then
        app_name=$(echo "$selected_item" | sed 's/^APP: //')
        exec_command=$("$SCRIPT_DIR/dmenu_desktop" "$app_name")
        if [ -n "$exec_command" ]; then
            # Let the shell interpret the exec_command directly.
            # It should handle quotes and paths as specified in the .desktop file.
            ${SHELL:-"/bin/sh"} -c "$exec_command" &
        fi
    else
        # Fallback for anything else (should not happen with prefixes)
        exec ${SHELL:-"/bin/sh"} -c "$selected_item" &
    fi
fi