#!/bin/bash
# Interactive dotfiles manager with GNU Stow

set -e  # Exit on error

# Default configuration
DOTFILES_DIR="${DOTFILES_DIR:-$HOME/dotfiles}"
STOW_TARGET="$HOME"
config_name=""
DRY_RUN=false
NO_PROMPT=false
AUTO_YES=false

# Use tput for portable colors if available
if command -v tput >/dev/null 2>&1; then
    RED=$(tput setaf 1)
    GREEN=$(tput setaf 2)
    YELLOW=$(tput setaf 3)
    BLUE=$(tput setaf 4)
    BOLD=$(tput bold)
    RESET=$(tput sgr0)
else
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    BOLD='\033[1m'
    RESET='\033[0m'
fi

# Help text
print_help() {
    cat << EOF
${BOLD}Dotfiles Manager${RESET}
Manage configuration files with GNU Stow.

${BOLD}Usage:${RESET}
  $(basename "$0") [OPTIONS] [CONFIG-NAME]

${BOLD}Options:${RESET}
  -h, --help           Show this help message
  -d, --dry-run        Preview changes without making them
  -y, --yes            Assume 'yes' to all prompts
  -n, --no-prompt      Non-interactive mode (fails if input needed)
  -t, --target DIR     Stow target directory (default: ~)
  --stow-options OPTS  Additional options to pass to stow
  --no-git             Skip git operations
  --no-backup          Skip backing up existing files

${BOLD}Examples:${RESET}
  $(basename "$0") polybar                 # Add polybar config
  $(basename "$0") -y zsh ~/.zshrc         # Add .zshrc without prompts
  $(basename "$0") -d i3                   # Preview adding i3 config
  $(basename "$0") -t /custom/target kitty # Stow to custom location

${BOLD}Environment:${RESET}
  DOTFILES_DIR  Directory containing dotfiles (default: ~/dotfiles)
EOF
    exit 0
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                print_help
                ;;
            -d|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -y|--yes)
                AUTO_YES=true
                shift
                ;;
            -n|--no-prompt)
                NO_PROMPT=true
                shift
                ;;
            -t|--target)
                STOW_TARGET="$2"
                shift 2
                ;;
            --stow-options)
                EXTRA_STOW_OPTS="$2"
                shift 2
                ;;
            --no-git)
                SKIP_GIT=true
                shift
                ;;
            --no-backup)
                SKIP_BACKUP=true
                shift
                ;;
            --)
                shift
                break
                ;;
            -*)
                echo "Error: Unknown option $1" >&2
                echo "Use --help for usage information" >&2
                exit 1
                ;;
            *)
                config_name="$1"
                shift
                # If there's another argument, treat it as source path
                if [[ $# -gt 0 ]] && [[ "$1" != -* ]]; then
                    USER_PROVIDED_PATH="$1"
                    shift
                fi
                break
                ;;
        esac
    done
}

print_header() {
    echo -e "${BLUE}========================================${RESET}"
    echo -e "${BLUE}  Dotfiles Manager${RESET}"
    echo -e "${BLUE}========================================${RESET}"
}

print_success() {
    echo -e "${GREEN}✓${RESET} $1"
}

print_warning() {
    echo -e "${YELLOW}⚠${RESET} $1"
}

print_error() {
    echo -e "${RED}✗${RESET} $1"
}

print_dry_run() {
    echo -e "${BOLD}[DRY RUN]${RESET} $1"
}

# Simple spinner for long operations
spinner() {
    local pid=$1
    local delay=0.1
    local spinstr='|/-\'
    while [ "$(ps a | awk '{print $1}' | grep $pid)" ]; do
        local temp=${spinstr#?}
        printf " [%c]  " "$spinstr"
        local spinstr=$temp${spinstr%"$temp"}
        sleep $delay
        printf "\b\b\b\b\b\b"
    done
    printf "    \b\b\b\b"
}

# Run command with spinner
run_with_spinner() {
    local msg="$1"
    shift
    local cmd=("$@")

    printf "%s " "$msg"
    ("${cmd[@]}" >/dev/null 2>&1) &
    local pid=$!
    spinner $pid
    wait $pid
    local status=$?
    if [ $status -eq 0 ]; then
        echo -e "${GREEN}✓${RESET}"
    else
        echo -e "${RED}✗${RESET}"
    fi
    return $status
}

check_dotfiles_dir() {
    if [ ! -d "$DOTFILES_DIR" ]; then
        print_error "Dotfiles directory not found: $DOTFILES_DIR"
        echo "Create it with: mkdir -p ~/dotfiles && cd ~/dotfiles && git init"
        exit 1
    fi
}

get_config_name() {
    # If user provided a config name via command line, use it
    if [ -n "$config_name" ]; then
        return 0
    fi

    # If no-prompt mode, we need a config name
    if [ "$NO_PROMPT" = true ]; then
        print_error "Config name required in non-interactive mode"
        echo "Usage: $(basename "$0") [OPTIONS] <config-name>"
        exit 1
    fi

    # Interactive mode: ask for config name
    echo -n "Enter config name (e.g., polybar, i3, alacritty): "
    read -r config_name

    if [ -z "$config_name" ]; then
        print_error "No config name provided"
        exit 1
    fi
}

detect_config_path() {
    local config_name="$1"
    local possible_paths=(
        "$HOME/.config/$config_name"
        "$HOME/.$config_name"
        "$HOME/.${config_name}rc"
        "$HOME/.${config_name}_config"
        "$HOME/$config_name"
    )

    for path in "${possible_paths[@]}"; do
        if [ -e "$path" ]; then
            echo "$path"
            return 0
        fi
    done

    # Return empty string instead of failing
    echo ""
}

detect_stow_structure() {
    local config_name="$1"
    local config_path="$2"

    # If user provided a path directly, use relative path from home
    if [[ "$config_path" == "$HOME"/* ]]; then
        local inner_path="${config_path#$HOME/}"
        echo "$inner_path"
    # If it's already a relative path or absolute path outside home
    elif [[ "$config_path" == ./* ]] || [[ "$config_path" == /* ]]; then
        # For paths outside home, we need to think about stow structure
        # This is complex - better to ask user or use config name
        print_warning "Path '$config_path' is outside home directory or relative"
        print_warning "Using config name '$config_name' as stow structure"
        echo "$config_name"
    else
        # Fallback to config name
        echo "$config_name"
    fi
}

backup_existing() {
    local target_path="$1"

    # Skip backup if requested
    if [ "$SKIP_BACKUP" = true ]; then
        print_warning "Skipping backup (--no-backup)"
        return 0
    fi

    local backup_path="${target_path}.backup.$(date +%Y%m%d_%H%M%S)"

    # Use atomic mv if possible, otherwise copy then remove
    if [ -e "$target_path" ]; then
        if [ "$DRY_RUN" = true ]; then
            print_dry_run "Would backup: $target_path → $backup_path"
            return 0
        fi

        print_warning "Backing up existing: $target_path → $backup_path"
        if ! mv "$target_path" "$backup_path" 2>/dev/null; then
            # If mv fails (e.g., across filesystems), copy then remove
            if [ -d "$target_path" ]; then
                cp -r "$target_path" "$backup_path" && rm -rf "$target_path"
            else
                cp "$target_path" "$backup_path" && rm -f "$target_path"
            fi
        fi
        echo "Original saved to: $backup_path"
    fi
}

add_config() {
    local config_name="$1"
    local config_path="$2"
    local stow_structure="$3"

    # Track operations for rollback
    local operations=()
    local rollback_needed=false

    print_header

    # Create directory structure in dotfiles
    local dotfiles_path="$DOTFILES_DIR/$config_name/$stow_structure"

    if [ "$DRY_RUN" = true ]; then
        print_dry_run "Would create: $dotfiles_path"
        print_dry_run "Would copy: $config_path → $dotfiles_path"
    else
        print_success "Creating: $dotfiles_path"
        mkdir -p "$(dirname "$dotfiles_path")"
        operations+=("created_dir:$(dirname "$dotfiles_path")")
    fi

    # Copy files - always copy to the exact dotfiles_path
    if [ "$DRY_RUN" = true ]; then
        if [ -d "$config_path" ]; then
            print_dry_run "Would copy directory: $config_path → $dotfiles_path"
        elif [ -f "$config_path" ]; then
            print_dry_run "Would copy file: $config_path → $dotfiles_path"
        fi
    else
        if [ -d "$config_path" ]; then
            print_success "Copying directory: $config_path"
            # For directories, copy contents to dotfiles_path
            mkdir -p "$dotfiles_path"
            cp -r "$config_path"/. "$dotfiles_path"/
            operations+=("copied_dir:$config_path:$dotfiles_path")
        elif [ -f "$config_path" ]; then
            print_success "Copying file: $config_path"
            cp "$config_path" "$dotfiles_path"
            operations+=("copied_file:$config_path:$dotfiles_path")
        else
            print_error "Not a file or directory: $config_path"
            return 1
        fi
        rollback_needed=true
    fi

    # Backup existing at target
    backup_existing "$config_path"

    # Stow it
    if [ "$DRY_RUN" = true ]; then
        print_dry_run "Would run: stow -v -t \"$STOW_TARGET\" $EXTRA_STOW_OPTS \"$config_name\""
    else
        cd "$DOTFILES_DIR"
        print_success "Creating symlinks with stow..."
        local stow_cmd="stow -v -t \"$STOW_TARGET\" $EXTRA_STOW_OPTS \"$config_name\""
        if eval "$stow_cmd"; then
            print_success "Stow completed successfully!"
            operations+=("stowed:$config_name:$STOW_TARGET")
        else
            print_error "Stow failed."
            if [ "$rollback_needed" = true ]; then
                print_warning "Attempting rollback..."
                rollback_operations "$config_name" "${operations[@]}"
            fi
            echo "Try: stow -t \"$STOW_TARGET\" --adopt $config_name"
            return 1
        fi
    fi

    # Git operations
    if [ "$SKIP_GIT" != true ] && [ -d "$DOTFILES_DIR/.git" ]; then
        if [ "$DRY_RUN" = true ]; then
            print_dry_run "Would add to git: $config_name/"
            print_dry_run "Would commit with message: feat: add $config_name configuration"
        else
            print_success "Adding to git..."
            git add "$config_name/"

            local commit_msg=""
            if [ "$NO_PROMPT" = true ] || [ "$AUTO_YES" = true ]; then
                commit_msg="feat: add $config_name configuration"
            else
                echo -n "Enter git commit message (or press Enter for default): "
                read -r commit_msg
                if [ -z "$commit_msg" ]; then
                    commit_msg="feat: add $config_name configuration"
                fi
            fi

            git commit -m "$commit_msg"
            print_success "Committed with message: $commit_msg"
        fi
    elif [ "$DRY_RUN" = true ] && [ -d "$DOTFILES_DIR/.git" ]; then
        print_dry_run "Would skip git (--no-git not set, git repo exists)"
    fi

    if [ "$DRY_RUN" = true ]; then
        print_dry_run "Configuration '$config_name' would be added to dotfiles!"
        print_dry_run "Files would be at: $DOTFILES_DIR/$config_name/"
        print_dry_run "Symlinks would be at: $config_path"
    else
        print_success "Configuration '$config_name' added to dotfiles!"
        echo ""
        echo "Files are now at: $DOTFILES_DIR/$config_name/"
        echo "Symlinks are at: $config_path"
    fi
}

# Rollback function
rollback_operations() {
    local config_name="$1"
    shift
    local operations=("$@")

    print_warning "Rolling back operations for $config_name..."

    # Process operations in reverse order
    for (( i=${#operations[@]} - 1; i>=0; i-- )); do
        local op="${operations[i]}"
        local type="${op%%:*}"
        local details="${op#*:}"

        case "$type" in
            "created_dir")
                if [ -d "$details" ] && [ -z "$(ls -A "$details")" ]; then
                    rmdir "$details" 2>/dev/null && print_success "Removed empty directory: $details"
                fi
                ;;
            "copied_file"|"copied_dir")
                local src="${details%%:*}"
                local dst="${details#*:}"
                if [ -e "$dst" ]; then
                    rm -rf "$dst" && print_success "Removed: $dst"
                fi
                ;;
            "stowed")
                local stow_details="${details#*:}"
                local target="${stow_details%%:*}"
                local package="${stow_details#*:}"
                cd "$DOTFILES_DIR"
                stow -D -t "$target" "$package" 2>/dev/null && print_success "Unstowed: $package from $target"
                ;;
        esac
    done

    print_warning "Rollback completed for $config_name"
}

main() {
    # Parse command line arguments first
    parse_args "$@"

    # Check if user provided a path directly via command line
    if [ -n "$USER_PROVIDED_PATH" ]; then
        config_path="$USER_PROVIDED_PATH"
        # Expand ~ and variables in user-provided path
        config_path=$(eval echo "$config_path")
        if [ ! -e "$config_path" ]; then
            print_error "Path does not exist: $config_path"
            exit 1
        fi
        print_success "Using provided path: $config_path"
    else
        # No config name provided at all
        if [ -z "$config_name" ]; then
            get_config_name ""
        fi

        check_dotfiles_dir

        print_success "Looking for: $config_name"

        # Detect where the config is
        config_path=$(detect_config_path "$config_name")

        if [ -z "$config_path" ]; then
            print_error "Could not find configuration for '$config_name'"
            echo "Common locations checked:"
            echo "  - ~/.config/$config_name/"
            echo "  - ~/.$config_name"
            echo "  - ~/.${config_name}rc"
            echo ""

            # Handle non-interactive mode
            if [ "$NO_PROMPT" = true ]; then
                print_error "Cannot prompt for path in non-interactive mode (--no-prompt)"
                echo "Please provide full path: $(basename "$0") $config_name /full/path"
                exit 1
            fi

            # Get and validate user input
            while true; do
                echo "Please specify full path:"
                read -r full_path

                # Basic validation: check if path exists and is within user's home
                if [ -z "$full_path" ]; then
                    print_error "No path provided. Try again or press Ctrl+C to cancel."
                    continue
                fi

                # Expand ~ and variables
                full_path=$(eval echo "$full_path")

                # Check if path exists
                if [ ! -e "$full_path" ]; then
                    print_error "Path does not exist: $full_path"
                    continue
                fi

                # Check if path is within user's home directory (security)
                if [[ "$full_path" != "$HOME"/* ]] && [[ "$full_path" != "$HOME" ]]; then
                    print_warning "Warning: Path is outside your home directory: $full_path"
                    if [ "$AUTO_YES" != true ]; then
                        read -p "Continue anyway? (y/N): " -n 1 -r
                        echo ""
                        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                            continue
                        fi
                    else
                        print_warning "Auto-accepting (--yes)"
                    fi
                fi

                config_path="$full_path"
                break
            done
        else
            print_success "Found at: $config_path"
        fi
    fi

    # Ask for confirmation (unless auto-yes or no-prompt or dry-run)
    if [ "$DRY_RUN" != true ] && [ "$AUTO_YES" != true ] && [ "$NO_PROMPT" != true ]; then
        echo ""
        echo "You are about to:"
        echo "1. Copy $config_path to $DOTFILES_DIR/$config_name/"
        echo "2. Backup original to $config_path.backup.[timestamp]"
        echo "3. Create symlinks with stow (target: $STOW_TARGET)"
        if [ "$SKIP_GIT" != true ] && [ -d "$DOTFILES_DIR/.git" ]; then
            echo "4. Commit to git"
        fi
        echo ""
        read -p "Continue? (y/N): " -n 1 -r
        echo ""

        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            print_warning "Cancelled"
            exit 0
        fi
    elif [ "$DRY_RUN" = true ]; then
        print_dry_run "Preview mode - no changes will be made"
    elif [ "$AUTO_YES" = true ]; then
        print_warning "Auto-accepting all prompts (--yes)"
    fi

    # Detect stow structure
    stow_structure=$(detect_stow_structure "$config_name" "$config_path")

    # Add the config
    add_config "$config_name" "$config_path" "$stow_structure"
}

# Run main function
main "$@"
